"""
Dapr service invocation helpers for {{ service_name }}.
"""
import asyncio
import logging
from typing import Any, Dict, Optional

import httpx

from app.core.config import settings

log = logging.getLogger(__name__)


class ServiceInvoker:
    """Helper for Dapr service invocation with retries."""

    def __init__(self):
        self.dapr_url = settings.dapr_http_url
        self.default_timeout = 5000  # ms
        self.max_retries = 3

    async def call(
        self,
        app_id: str,
        method: str,
        data: Dict[str, Any],
        timeout_ms: Optional[int] = None,
    ) -> Dict[str, Any]:
        """
        Invoke a method on another Dapr-enabled service.

        Args:
            app_id: Target service Dapr app ID
            method: Method name to invoke
            data: Request payload
            timeout_ms: Request timeout in milliseconds

        Returns:
            Response data

        Raises:
            httpx.HTTPError: If invocation fails
        """
        timeout = timeout_ms or self.default_timeout
        url = f"{self.dapr_url}/v1.0/invoke/{app_id}/method/{method}"

        try:
            async with httpx.AsyncClient(timeout=timeout / 1000) as client:
                response = await client.post(url, json=data)
                response.raise_for_status()
                return response.json()

        except httpx.HTTPError as e:
            log.error(f"Service invocation failed: {app_id}.{method} - {e}")
            raise

    async def call_with_retry(
        self,
        app_id: str,
        method: str,
        data: Dict[str, Any],
        timeout_ms: Optional[int] = None,
        max_retries: Optional[int] = None,
        backoff_ms: int = 100,
    ) -> Optional[Dict[str, Any]]:
        """
        Invoke with exponential backoff retry.

        Args:
            app_id: Target service Dapr app ID
            method: Method name to invoke
            data: Request payload
            timeout_ms: Request timeout in milliseconds
            max_retries: Number of retry attempts
            backoff_ms: Initial backoff in milliseconds

        Returns:
            Response data or None if all retries fail
        """
        retries = max_retries or self.max_retries

        for attempt in range(retries):
            try:
                return await self.call(app_id, method, data, timeout_ms)

            except httpx.HTTPError as e:
                if attempt == retries - 1:
                    log.error(f"Service invocation failed after {retries} attempts")
                    return None

                log.warning(
                    f"Service invocation failed (attempt {attempt + 1}/{retries}), "
                    f"retrying..."
                )
                await asyncio.sleep(backoff_ms * (2 ** attempt) / 1000)

        return None


# Global invoker instance
invoker = ServiceInvoker()
