"""
Dapr state management helpers for {{ service_name }}.
"""
import asyncio
import logging
from typing import Any, Dict, Optional, TypeVar, Generic

import httpx
from pydantic import BaseModel

from app.core.config import settings

log = logging.getLogger(__name__)

T = TypeVar("T", bound=BaseModel)


class DaprState(Generic[T]):
    """
    Helper for Dapr state management with ETag concurrency.

    Provides CRUD operations on Dapr state store with optimistic
    concurrency control using ETags.
    """

    def __init__(self):
        self.dapr_url = settings.dapr_http_url
        self.store_name = settings.STATE_STORE_NAME
        self.state_url = f"{self.dapr_url}/v1.0/state/{self.store_name}"
        self.bulk_url = f"{self.dapr_url}/v1.0/state"

    async def get(self, key: str) -> Optional[Dict[str, Any]]:
        """
        Get state by key.

        Args:
            key: State key

        Returns:
            State data or None if not found
        """
        url = f"{self.state_url}/{key}"
        try:
            async with httpx.AsyncClient(timeout=5.0) as client:
                response = await client.get(url)

                if response.status_code == 404:
                    return None

                response.raise_for_status()
                data = response.json()

                # Extract ETag if present
                etag = response.headers.get("ETag", "")
                if etag:
                    data["_etag"] = etag

                return data

        except httpx.HTTPError as e:
            log.error(f"Error getting state {key}: {e}")
            raise

    async def save(
        self,
        key: str,
        value: Dict[str, Any],
        etag: Optional[str] = None,
        retries: int = 3,
    ) -> Optional[str]:
        """
        Save state with optional ETag for concurrency control.

        Args:
            key: State key
            value: State data
            etag: ETag for optimistic concurrency
            retries: Number of retries on ETag conflict

        Returns:
            New ETag if successful, None otherwise
        """
        state_item = {
            "key": key,
            "value": value,
        }

        if etag:
            state_item["etag"] = etag

        for attempt in range(retries):
            try:
                async with httpx.AsyncClient(timeout=5.0) as client:
                    response = await client.post(self.bulk_url, json=[state_item])

                    if response.status_code == 200:
                        # Return new ETag
                        new_etag = response.headers.get("ETag", "")
                        log.debug(f"Saved state {key}, ETag: {new_etag}")
                        return new_etag

                    # ETag conflict - retry with fresh data
                    if response.status_code == 409 or response.status_code == 412:
                        if attempt < retries - 1:
                            await asyncio.sleep(0.1 * (2 ** attempt))
                            continue

                    response.raise_for_status()

            except httpx.HTTPError as e:
                if attempt == retries - 1:
                    log.error(f"Error saving state {key}: {e}")
                    raise
                await asyncio.sleep(0.1 * (2 ** attempt))

        return None

    async def delete(self, key: str, etag: Optional[str] = None) -> bool:
        """
        Delete state by key.

        Args:
            key: State key
            etag: ETag for concurrency control

        Returns:
            True if deleted successfully
        """
        state_item = {
            "key": key,
            "value": None,
        }

        if etag:
            state_item["etag"] = etag

        try:
            async with httpx.AsyncClient(timeout=5.0) as client:
                response = await client.post(
                    self.bulk_url,
                    json=[state_item],
                    params={"delete_state": True}
                )
                response.raise_for_status()
                log.debug(f"Deleted state {key}")
                return True

        except httpx.HTTPError as e:
            log.error(f"Error deleting state {key}: {e}")
            raise

    async def get_keys(self) -> list[str]:
        """
        Get all keys in the state store.

        Returns:
            List of state keys
        """
        try:
            async with httpx.AsyncClient(timeout=5.0) as client:
                response = await client.get(f"{self.bulk_url}/?metadata={self.store_name}")
                response.raise_for_status()
                data = response.json()
                return data.get("keys", [])

        except httpx.HTTPError as e:
            log.error(f"Error getting state keys: {e}")
            raise


# Global state instance
state = DaprState()
