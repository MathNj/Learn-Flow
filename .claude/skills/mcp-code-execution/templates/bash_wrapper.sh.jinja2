#!/bin/bash
#
# {{ description }}
#
# Generated by mcp-code-execution skill.
# MCP Server: {{ mcp_server }}
# Tool: {{ tool }}
# Language: bash
#

set -euo pipefail

# Script configuration
MCP_SERVER="${MCP_SERVER:-{{ mcp_server }}}}"
TOOL_NAME="${TOOL_NAME:-{{ tool }}}}"
LIMIT="${LIMIT:-{{ limit | default(10) }}}"

# Colors for output (disable with NO_COLOR=1)
if [[ -z "${NO_COLOR:-}" ]]; then
    COLOR_ERROR='\033[0;31m'
    COLOR_SUCCESS='\033[0;32m'
    COLOR_RESET='\033[0m'
else
    COLOR_ERROR=''
    COLOR_SUCCESS=''
    COLOR_RESET=''
fi

# Error handler
error_exit() {
    echo -e "${COLOR_ERROR}Error: $1${COLOR_RESET}" >&2
    echo '{"status": "error", "message": "'"$1"'"}' >&2
    exit 1
}

# Trap errors
trap 'error_exit "Script failed at line $LINENO"' ERR

# Help function
show_help() {
    cat << EOF
Usage: $(basename "$0") [OPTIONS]

{{ description }}

Options:
    --server NAME       MCP server name (default: {{ mcp_server }})
    --tool NAME         Tool name (default: {{ tool }})
    --filter EXPR       Filter expression for results
    --limit N           Maximum results to return (default: {{ limit | default(10) }})
{% for arg in tool_args %}
    --{{ arg.name }}    {{ arg.help }}{% if arg.default %} (default: {{ arg.default }}){% endif %}{% if arg.required %} [required]{% endif %}
{% endfor %}
    -h, --help          Show this help message

Environment Variables:
    MCP_SERVER          Default MCP server name
    TOOL_NAME           Default tool name
    LIMIT               Default result limit
    NO_COLOR=1          Disable colored output

Examples:
    # Basic usage
    $(basename "$0") --sheet-id abc123

    # With filter and limit
    $(basename "$0") --sheet-id abc123 --filter '.status=="pending"' --limit 5

EOF
}

# Default values
FILTER_EXPR=""
{% for arg in tool_args %}
{{ arg.name | upper }}="{{ arg.default | default('') }}"
{% endfor %}

# Parse arguments
while [[ $# -gt 0 ]]; do
    case $1 in
        --server)
            MCP_SERVER="$2"
            shift 2
            ;;
        --tool)
            TOOL_NAME="$2"
            shift 2
            ;;
        --filter)
            FILTER_EXPR="$2"
            shift 2
            ;;
        --limit)
            LIMIT="$2"
            shift 2
            ;;
{% for arg in tool_args %}
        --{{ arg.name }})
            {{ arg.name | upper }}="$2"
            shift 2
            ;;
{% endfor %}
        -h|--help)
            show_help
            exit 0
            ;;
        *)
            error_exit "Unknown option: $1. Use --help for usage information."
            ;;
    esac
done

# Validate required arguments
{% for arg in tool_args %}
{% if arg.required %}
if [[ -z "${{{ arg.name | upper }}}}" ]]; then
    error_exit "{{ arg.name }} is required. Use --help for usage information."
fi
{% endif %}
{% endfor %}

# Build tool parameters
TOOL_PARAMS="{"
{% for arg in tool_args %}
TOOL_PARAMS+="{% if not loop.first %}, {% endif %}{{ arg.param_name }}: ${{ '{' }}{{ arg.name | upper }}{{ '}' }}"
{% endfor %}
TOOL_PARAMS+="}"

# Call MCP server
call_mcp_server() {
    local server="$1"
    local tool="$2"
    local params="$3"

    # Check if jq is available
    if ! command -v jq &> /dev/null; then
        error_exit "jq is required but not installed. Install with: apt-get install jq or brew install jq"
    fi

    # Check if curl is available
    if ! command -v curl &> /dev/null; then
        error_exit "curl is required but not installed"
    fi

    # Placeholder for actual MCP server call
    # Replace with actual MCP client implementation
    # For HTTP-based MCP servers:
    # curl -s "http://$server/tools/$tool" -d "$params"

    # Example: Simulated call
    echo '{"status": "success", "data": []}'
}

# Main execution
main() {
    # Call MCP server
    RESPONSE=$(call_mcp_server "$MCP_SERVER" "$TOOL_NAME" "$TOOL_PARAMS")

    # Check for errors in response
    if ! echo "$RESPONSE" | jq -e '.status' &> /dev/null; then
        error_exit "Invalid response from MCP server"
    fi

    # Extract data
    STATUS=$(echo "$RESPONSE" | jq -r '.status // "error"')

    if [[ "$STATUS" != "success" ]]; then
        MESSAGE=$(echo "$RESPONSE" | jq -r '.message // "Unknown error"')
        error_exit "$MESSAGE"
    fi

    # Apply filter if provided
    if [[ -n "$FILTER_EXPR" ]]; then
        DATA=$(echo "$RESPONSE" | jq -c ".data | [$FILTER_EXPR] | .[0:$LIMIT]")
    else
        DATA=$(echo "$RESPONSE" | jq -c ".data | .[0:$LIMIT]")
    fi

    # Build output
    COUNT=$(echo "$DATA" | jq 'length')
    OUTPUT="{\"status\": \"success\", \"count\": $COUNT, \"data\": $DATA}"

    # Print output
    echo "$OUTPUT"

    exit 0
}

# Run main
main
